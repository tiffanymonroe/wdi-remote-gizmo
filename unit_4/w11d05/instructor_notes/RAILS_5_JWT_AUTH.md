![ga](http://mobbook.generalassemb.ly/ga_cog.png)

# WDI-GIZMO

---
Title: Rails 5 API Authentication <br>
Type: Walkthrough<br>
Creator: Thom Page <br>
Topics: Setting up JSON Web Tokens for a Rails 5 API <br>

---

# Rails 5 API Authentication

Restrict access to your Rails 5 API unless a user provides a JSON Web Token generated by the server.

Rails 5 API does not store a 'session' server-side. Sessions aren't really what APIs are about: they just serve information, setting restrictions with API keys.

Instead of storing the 'session' on the server, we will store it in the browser. However, the server will need to generate some kind of secret message to trade with the browser so we can pair them up. For the secret message we will trade between server and browser, we will use a JSON Web Token which is an encrypted piece of JSON data.

* How it would work with a front-end

![](https://i.imgur.com/hZcoOia.png)

This lesson is for JWT on the backend only. See also: Angular Localstorage JWT Auth for frontend component of this lesson.

<br>

## Setting up Rails to create a User with hashed password


![](https://i.imgur.com/nJzHECx.png)

Create a user with two columns: `username` and `password_digest`

![](https://i.imgur.com/gI8fIbG.png)

![](https://i.imgur.com/CgVseg8.png)

To use `has_secure_password`, we must have the `password_digest` column and the `bcrypt gem`.

Documentation:

![](https://i.imgur.com/2F7QnwE.png)


Get bcrypt bundled:

![](https://i.imgur.com/hKBD5XU.png)

![](https://i.imgur.com/3eLg5y8.png)

![](https://i.imgur.com/QR54Qil.png)

![](https://i.imgur.com/InxRAhF.png)

Schema:

![](https://i.imgur.com/lKEqwD9.png)

<br>
<hr>

# SIGN UP

Test User in rails console - password is hashed for us.

**Create a user**

Even though we called our column `password_digest`, we enter our password with a regular `password` column.

![](https://i.imgur.com/y0ZcIGk.png)

Save the user.

![](https://i.imgur.com/2ac7bC4.png)

[has secure password validation](http://api.rubyonrails.org/classes/ActiveModel/SecurePassword/ClassMethods.html#method-i-has_secure_password)

Documentation

![](https://i.imgur.com/5COikd7.png)

<br>
<hr>

# LOGIN

![](https://i.imgur.com/nOzz6Tz.png)

Add a **collection** not a **member**. A member will add a param to the route, which we don't want.

We're going to add a login action to our `users_controller`. Because we are using `has_secure_password`, we are given an `.authenticate` method on our user for free.

  ```ruby
  def login
      user = User.find_by(username: params[:user][:username])
      if user && user.authenticate(params[:user][:password])
        render json: {status: 200, user: user}
      else
        render json: {status: 401, message: "Unauthorized"}
      end
  end
  ```

![](https://i.imgur.com/KSV5MHR.png)

Let's test this. Login as the user you previously created. If successful, should get the user info in response. If unsuccessful, should get a 401 (Unauthorized).

![](https://i.imgur.com/DQqnV4B.png)

![](https://i.imgur.com/WM66WmT.png)

Where does the `.authenticate` method come from? It comes from [`has_secure_password`](http://api.rubyonrails.org/classes/ActiveModel/SecurePassword/ClassMethods.html#method-i-has_secure_password).

Now that we can log in, let's keep track of our logged-in users using **JSON Web Tokens** or **JWT**.

<br>
<hr>

# Tokens

Let's install the following gems:

```
gem 'jwt'
```

This is so we can generate and decode JSON Web Tokens on our Rails server.

```
gem 'dotenv-rails', '~> 2.1', '>= 2.1.1'
```

This is so we can set Environment Variables for use in our JSON Web Tokens. (You might have used dotenv in Express. This is the Rails version).


From the docs:

> What is JSON Web Token?

> JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object.

Good reading here:

[JSON Web Tokens](https://jwt.io/introduction/)

![](https://i.imgur.com/obNqWIa.png)

All we are really sending is an encoded piece of information. When the information is decoded, it's a good ole Javascript Object with keys and values and such. Useful stuff.

Another picture of the Auth process using JWT (from the docs):

![](https://i.imgur.com/YVoufUm.png)

We will be encoding and decoding our JWTs using the `jwt-ruby` gem:

[jwt-ruby gem docs](https://github.com/jwt/ruby-jwt)


## Generate a JWT

After we have authenticated our user, we want to generate a JWT for them so we can keep them in our 'session'.

```
token = create_token(user.id, user.username)
```

![](https://i.imgur.com/2KaOQaA.png)

`create_token` is a method we will write to trigger the token generation process.

```ruby
def create_token(id, username)
  JWT.encode(payload(id, username), ENV['JWT_SECRET'], 'HS256')
end
```

![](https://i.imgur.com/2PhVUWf.png)

`JWT` is how we use use the `jwt` gem. `JWT.encode` is a method within the `jwt` gem. It will encode / generate a JSON Web Token for us. A token has a **header**, a **payload**, and a **signature**. These are the three arguments that we pass to the `JWT.encode` method.

Our create_token method is calling on another method called `payload` that we will write. All this method does is return an object (or hash) that includes our user's info.

```
  def payload(id, username)
    {
      exp: (Time.now + 30.minutes).to_i,
      iat: Time.now.to_i,
      iss: ENV['JWT_ISSUER'],
      user: {
        id: id,
        username: username
      }
    }
  end
```

![](https://i.imgur.com/goZUFdu.png)

<br>
<hr>
**Extra**

To configure the timezone, add this to `application.rb`

```
class Application < Rails::Application
  config.time_zone = 'Eastern Time (US & Canada)'
end
```

Now this will also work for expiration on your JWT payload

```
1.day.from_now
```

<br>

### ENV Variables

Environment variables, or ENV for short, are variables that exist _outside_ of your app. They should not exist within your code. This is to prevent people from seeing on Github and whatnot. Rather, these secret variables exist in the 'environment' is which the app is located.

We can set Environment Variables with the `dotenv-rails` gem. It allows us to set them inside of a file `.env`

1. `touch .env` in the root of your rails project

  ```
JWT_SECRET=whateversecretyouwant
JWT_ISSUER=whoeveryouwant
  ```

  ![](https://i.imgur.com/oLGXkG2.png)

 * Make sure `dotenv-rails` has been bundled.

2. Open your rails console and enter `ENV['JWT-SESSION_SECRET']`

  This is a file that you can store information in and access from the outside world without worrying about them being pushed to github. Things like API keys and secrets, passwords, token and session secrets etc.

  ![](https://i.imgur.com/mFtIzRh.png)

**BUG**  
If for some reason it stubbornly refuses to work, try writing this into your `config/application.rb` file, inside the module:

```
require "dotenv-rails"
```

![](https://i.imgur.com/2wB7C1E.png)

<br>

**ELSE**

  * Write `.env` in to your `.gitignore`

 <br>
 <hr>

## Test: GENERATE A TOKEN


Put it into the rendered json with login authentication:

 ![](https://i.imgur.com/cLoyMAJ.png)


## Test: Postman

 ![](https://i.imgur.com/Jz17VdD.png)

 response has all the stuff it had before, plus a JWT string

 ![](https://i.imgur.com/BxFiOll.png)

 Congrats! We can log in.

 <br>


# ACCESS: AUTHENTICATE ROUTES
## Authentication methods

We have done sign up and log in, now we need to think about using those for access.

We want our server to stop our user from accessing routes if the user do not have a valid or correct JSON Web Token.

Add the following methods to your ApplicationController. This controller is the parent of all your other controllers. All methods that are written in here will be inherited by all others.

Let's make a method that is available to all of our controllers that will authenticate the JWT, and tell us if the user is allowed.

Test method in ApplicationController:

![](https://i.imgur.com/zqqhDL4.png)

run the authenticate_token method for all user actions except login and create:

![](https://i.imgur.com/AAXDdc5.png)

[Controller filters](http://guides.rubyonrails.org/action_controller_overview.html#filters)

[Active Record callbacks](http://api.rubyonrails.org/classes/ActiveRecord/Callbacks.html)

`/localhost:3000/users`

the puts statement in the console appears (the test worked):

![](https://i.imgur.com/6CAhvSE.png)

What we want to do is send a 401 if the incoming token does not exist (if there is no Authorization header) or is not a valid token:

```
render json: { status: 401, message: 'Unauthorized' } unless decode_token(bearer_token)
```

![](https://i.imgur.com/oJu05nt.png)


What we are doing is passing the result of a method `bearer_token` into a method `decode_token`. We need to write these methods.

Let's get `bearer_token` working and just have a shell for `decode_token` for now. All we want `bearer_token` to do is parse the incoming header from the frontend.

![](https://i.imgur.com/BOPeon0.png)

```
class ApplicationController < ActionController::API

  def authenticate_token
    puts "AUTHENTICATE JWT"
    render json: { status: 401, message: 'Unauthorized' } unless decode_token(bearer_token)
  end

  def bearer_token
    puts "BEARER TOKEN"
    puts header = request.env["HTTP_AUTHORIZATION"]
  end

  def decode_token(token_input)
    puts "DECODE TOKEN"
  end

end
```




request.env:

> request.env is a ruby array that contains information about a visiting userâ€™s and server environments.

[request.env](http://blogofchirag.blogspot.com/2008/09/variables-in-request-env-ruby-on-rails.html)


## Passing tokens via postman

Send a request to see `localhost:3000/users`

Under headers:

The key is `Authorization` the value is `Bearer <token>`. Note: this is right there in the [docs](https://jwt.io/introduction/).

We will be denied, but we should see the console output for the `request.env` Authorization header.

![](https://i.imgur.com/QFxwqTI.png)

We should see the puts statements, including the one that shows us what was in the Authorization header:

![](https://i.imgur.com/cwqRYJ0.png)

## regex

Use Regular Expressions to pass just the token without the 'Bearer':

![](https://i.imgur.com/kQtkcNA.png)

See the result in Terminal:

![](https://i.imgur.com/6kgmf8n.png)


## decode token

Make it so that `bearer_token` returns its result, and that we send a puts to test that `decode_token` receives the JWT

![](https://i.imgur.com/fPInUVe.png)

Terminal:

![](https://i.imgur.com/lVxh88c.png)

Add in the decode method and send a response with the decoded token stuff:

![](https://i.imgur.com/LYuxzyU.png)

**NOTE** If you get an error like

```bash
JWT::IncorrectAlgorithm (An algorithm must be specified):
  
app/controllers/application_controller.rb:21:in `decode_token'
app/controllers/application_controller.rb:8:in `authenticate_token'
```

You will need to pass a forth argument to the `JWT.decode()` method:

```ruby
    token = JWT.decode(token_input, ENV["JWT_SECRET"], true, { :algorithm => 'HS256'})
```

Postman response. The decoded token information looks like this:

![](https://i.imgur.com/NGXWngZ.png)

Make it so that `decode_token` returns the decoded token. If the decode fails, the method will error, meaning that the original authentication will fail. Otherwise, you should have access to the users route:
![](https://i.imgur.com/Zy5inkb.png)

Add in a convenient message in case of failure (rescue the error)

![](https://i.imgur.com/shwyZK8.png)
<br>
<hr>

## Currently logged in user

See the currently logged in user's details server-side:

in application_controller.rb

![](https://i.imgur.com/GLHXSPL.png)

Go to the the show route and just see who's logged in `localhost:3000/users/1`

![](https://i.imgur.com/d1XoPzI.png)

![](https://i.imgur.com/1U3wKrW.png)

<br>

Restrict a user from user-params routes if they are the wrong user:

![](https://i.imgur.com/Cq4qUOk.png)

```
  before_action :authorize_user, except: [:login, :create, :index]
```

![](https://i.imgur.com/502WNUL.png)

![](https://i.imgur.com/zDSJUdE.png)

<br>
<hr>
